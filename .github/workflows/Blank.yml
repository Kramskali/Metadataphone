# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
#!/usr/bin/env python3
"""
Test suite for Metadata Forensics Suite
=======================================
Run basic tests to verify functionality.

Usage:
    python test_suite.py
"""

import os
import sys
import tempfile
import json
from io import StringIO

# Import the main suite
from metadata_suite import (
    MetadataCollector, MetadataSpoofer, MetadataVerifier, PhoneMetadata,
    gps_to_decimal, decimal_to_gps, calculate_hash, format_bytes
)

def test_utils():
    """Test utility functions."""
    print("Testing utility functions...")
    
    # Test GPS conversion (EXIF format with rationals)
    gps_tuple = ((40, 1), (42, 1), (30, 1))  # 40° 42' 30" N
    decimal = gps_to_decimal(gps_tuple, 'N')
    assert decimal is not None and decimal > 0, "GPS to decimal conversion failed"
    assert abs(decimal - 40.7083) < 0.01, f"GPS decimal value incorrect: {decimal}"
    
    # Test reverse conversion
    gps_back, direction = decimal_to_gps(decimal)
    assert direction == 'N', "Decimal to GPS conversion failed"
    assert gps_back[0][0] == 40, "Degrees conversion failed"
    
    # Test format_bytes
    assert format_bytes(1024) == "1.00 KB", "Format bytes failed"
    assert format_bytes(1048576) == "1.00 MB", "Format bytes failed"
    
    # Test hash calculation
    import tempfile
    with tempfile.NamedTemporaryFile(delete=False) as f:
        f.write(b"test content")
        temp_path = f.name
    hash_result = calculate_hash(temp_path, 'md5')
    assert len(hash_result) == 32, "MD5 hash length incorrect"
    os.unlink(temp_path)
    
    print("  ✓ Utility functions passed")
    return True

def test_collector():
    """Test metadata collector."""
    print("Testing MetadataCollector...")
    
    collector = MetadataCollector()
    
    # Create a test image
    try:
        from PIL import Image
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as f:
            test_img_path = f.name
        
        # Create simple test image
        img = Image.new('RGB', (100, 100), color='red')
        img.save(test_img_path, 'JPEG')
        img.close()
        
        # Test filesystem metadata
        fs_meta = collector.extract_filesystem_metadata(test_img_path)
        assert 'size_bytes' in fs_meta, "Filesystem metadata extraction failed"
        assert 'timestamps' in fs_meta, "Timestamp extraction failed"
        
        # Test hash calculation
        hashes = collector.calculate_hashes(test_img_path)
        assert 'md5' in hashes, "MD5 hash calculation failed"
        assert 'sha256' in hashes, "SHA256 hash calculation failed"
        
        # Test EXIF extraction
        exif = collector.extract_exif(test_img_path)
        assert 'format' in exif, "EXIF extraction failed"
        assert exif['format'] == 'JPEG', "Wrong format detected"
        
        # Test full collection
        result = collector.collect_all(test_img_path, include_network=False)
        assert 'exif_data' in result, "Full collection failed"
        assert 'filesystem_metadata' in result, "Full collection failed"
        
        # Cleanup
        os.unlink(test_img_path)
        
        print("  ✓ MetadataCollector passed")
        return True
        
    except ImportError:
        print("  ⚠ PIL not available, skipping collector tests")
        return True
    except Exception as e:
        print(f"  ✗ MetadataCollector failed: {e}")
        return False

def test_spoofer():
    """Test metadata spoofer."""
    print("Testing MetadataSpoofer...")
    
    try:
        from PIL import Image
        import piexif
        
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as f:
            test_img_path = f.name
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as f:
            output_path = f.name
        
        # Create test image with some EXIF
        img = Image.new('RGB', (100, 100), color='blue')
        
        # Add basic EXIF
        exif_dict = {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}
        exif_dict["0th"][piexif.ImageIFD.Make] = b"TestCamera"
        exif_bytes = piexif.dump(exif_dict)
        img.save(test_img_path, 'JPEG', exif=exif_bytes)
        img.close()
        
        spoofer = MetadataSpoofer()
        
        # Test GPS spoofing
        result = spoofer.spoof_exif(
            test_img_path, output_path,
            gps="48.8566,2.3522",
            timestamp="2023-06-15T14:30:00",
            device="Canon EOS 5D",
            software="Adobe Lightroom"
        )
        assert result['success'], f"Spoofing failed: {result.get('error')}"
        assert result['modifications']['gps'], "GPS modification not recorded"
        
        # Test metadata stripping
        strip_result = spoofer.strip_metadata(test_img_path, output_path)
        assert strip_result['success'], "Metadata stripping failed"
        
        # Test scenario generation
        scenario_result = spoofer.generate_scenario('vacation', test_img_path, output_path)
        assert scenario_result['success'], "Scenario generation failed"
        assert 'scenario' in scenario_result, "Scenario data not returned"
        
        # Test timestamp modification
        ts_result = spoofer.modify_timestamps(test_img_path, mtime="2020-01-01T00:00:00")
        assert ts_result['success'], "Timestamp modification failed"
        
        # Cleanup
        os.unlink(test_img_path)
        os.unlink(output_path)
        
        print("  ✓ MetadataSpoofer passed")
        return True
        
    except ImportError:
        print("  ⚠ PIL or piexif not available, skipping spoofer tests")
        return True
    except Exception as e:
        print(f"  ✗ MetadataSpoofer failed: {e}")
        return False

def test_verifier():
    """Test metadata verifier."""
    print("Testing MetadataVerifier...")
    
    try:
        from PIL import Image
        import piexif
        
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as f:
            test_img_path = f.name
        
        # Create test image with EXIF
        img = Image.new('RGB', (100, 100), color='green')
        
        # Add EXIF with future date (should trigger FAKE detection)
        exif_dict = {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}
        future_date = "2099:01:01 00:00:00"
        exif_dict["Exif"][piexif.ExifIFD.DateTimeOriginal] = future_date.encode()
        exif_dict["0th"][piexif.ImageIFD.Software] = b"Adobe Photoshop"
        exif_dict["0th"][piexif.ImageIFD.Make] = b"Canon"
        
        # Add GPS
        exif_dict["GPS"][piexif.GPSIFD.GPSLatitude] = ((40, 1), (42, 1), (0, 1))
        exif_dict["GPS"][piexif.GPSIFD.GPSLatitudeRef] = b"N"
        exif_dict["GPS"][piexif.GPSIFD.GPSLongitude] = ((74, 1), (0, 1), (0, 1))
        exif_dict["GPS"][piexif.GPSIFD.GPSLongitudeRef] = b"W"
        
        exif_bytes = piexif.dump(exif_dict)
        img.save(test_img_path, 'JPEG', exif=exif_bytes)
        img.close()
        
        verifier = MetadataVerifier()
        report = verifier.verify(test_img_path)
        
        assert report.overall_result is not None, "Verification returned no result"
        assert 0 <= report.confidence_score <= 1, "Invalid confidence score"
        assert len(report.findings) > 0, "No findings returned"
        
        # Check for future date detection
        future_findings = [f for f in report.findings 
                          if f.check == 'Future Date' and f.result == 'FAKE']
        assert len(future_findings) > 0, "Future date not detected"
        
        # Cleanup
        os.unlink(test_img_path)
        
        print("  ✓ MetadataVerifier passed")
        return True
        
    except ImportError:
        print("  ⚠ PIL not available, skipping verifier tests")
        return True
    except Exception as e:
        print(f"  ✗ MetadataVerifier failed: {e}")
        return False

def test_phone_metadata():
    """Test phone metadata module."""
    print("Testing PhoneMetadata...")
    
    phone = PhoneMetadata()
    
    # Test cell info (may return limited data without root)
    cell_info = phone.get_cell_info()
    assert 'cell_towers' in cell_info, "Cell info structure invalid"
    
    # Test WiFi info
    wifi_info = phone.get_wifi_info()
    assert 'networks' in wifi_info, "WiFi info structure invalid"
    
    # Test movement analysis
    test_logs = [
        {'timestamp': 1699123456, 'cell_id': '12345', 'gps': {'lat': 40.7128, 'lon': -74.0060}},
        {'timestamp': 1699123516, 'cell_id': '12346', 'gps': {'lat': 40.7130, 'lon': -74.0062}},
        # Impossible speed entry
        {'timestamp': 1699123576, 'cell_id': '99999', 'gps': {'lat': 35.6762, 'lon': 139.6503}},
    ]
    
    analysis = phone.analyze_movement(test_logs)
    assert 'suspicious_patterns' in analysis, "Movement analysis structure invalid"
    
    # Check for impossible speed detection
    impossible_speeds = [p for p in analysis['suspicious_patterns'] 
                        if p['type'] == 'impossible_speed']
    assert len(impossible_speeds) > 0, "Impossible speed not detected"
    
    # Test log parsing
    log_line = "1699123456,12345,100,310,260,40.7128,-74.0060,-75"
    parsed = phone.parse_cell_log(log_line)
    assert parsed is not None, "Log parsing failed"
    assert parsed['cell_id'] == '12345', "Parsed cell_id incorrect"
    
    print("  ✓ PhoneMetadata passed")
    return True

def test_cli():
    """Test CLI interface."""
    print("Testing CLI interface...")
    
    from metadata_suite import create_parser
    
    parser = create_parser()
    
    # Test collect command parsing
    args = parser.parse_args(['collect', '-i', 'test.jpg'])
    assert args.command == 'collect', "Collect command parsing failed"
    assert args.input == 'test.jpg', "Input argument parsing failed"
    
    # Test spoof command parsing
    args = parser.parse_args(['spoof', '-i', 'in.jpg', '-o', 'out.jpg', '--gps', '40.7128,-74.0060'])
    assert args.command == 'spoof', "Spoof command parsing failed"
    assert args.gps == '40.7128,-74.0060', "GPS argument parsing failed"
    
    # Test verify command parsing
    args = parser.parse_args(['verify', '-i', 'test.jpg', '--compact'])
    assert args.command == 'verify', "Verify command parsing failed"
    assert args.compact == True, "Compact flag parsing failed"
    
    # Test phone command parsing
    args = parser.parse_args(['phone', '--cell-info'])
    assert args.command == 'phone', "Phone command parsing failed"
    assert args.cell_info == True, "Cell-info flag parsing failed"
    
    print("  ✓ CLI interface passed")
    return True

def run_all_tests():
    """Run all tests."""
    print("=" * 50)
    print("Metadata Forensics Suite - Test Suite")
    print("=" * 50)
    print()
    
    tests = [
        test_utils,
        test_collector,
        test_spoofer,
        test_verifier,
        test_phone_metadata,
        test_cli
    ]
    
    passed = 0
    failed = 0
    
    for test in tests:
        try:
            if test():
                passed += 1
            else:
                failed += 1
        except Exception as e:
            print(f"  ✗ {test.__name__} crashed: {e}")
            failed += 1
        print()
    
    print("=" * 50)
    print(f"Results: {passed} passed, {failed} failed")
    print("=" * 50)
    
    return failed == 0

if __name__ == '__main__':
    success = run_all_tests()
    sys.exit(0 if success else 1)
